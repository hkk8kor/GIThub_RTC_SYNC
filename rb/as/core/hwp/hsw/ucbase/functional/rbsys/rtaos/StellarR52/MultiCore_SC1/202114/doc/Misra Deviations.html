<html xmlns="http://www.w3.org/1999/xhtml"><head><title>RTA-OS MISRA Report: rtaos_ccas_stellar_mcore_sc1</title><meta http-equiv="Content-Type" content="text/html; charset=ANSI" /><link href="Misra Deviations.css" media="all" rel="Stylesheet" type="text/css" /></head><body><div id="header"><h1>RTA-OS MISRA Report: rtaos_ccas_stellar_mcore_sc1</h1></div><div id="content"><div id="main"><h2>Toolchain Report</h2><table><tr xmlns=""><td>Target</td><td>Stellar R52/GHS (5.0.4)</td></tr><tr xmlns=""><td>Code Generator</td><td>RTA-OS (12.1.0.34682)</td></tr><tr xmlns=""><td>Code Checker</td><td>PC-lint for C/C++ (NT) (9.00L)</td></tr><tr xmlns=""><td>Requirements Checker</td><td>RReqs (svn 23020)</td></tr><tr xmlns=""><td>C Standard</td><td>The C99 version of the C language is used with GNU extensions</td></tr><tr xmlns=""><td>Compiler defects</td><td>- refer to release note -</td></tr><tr xmlns=""><td>Compiler implementaton details</td><td>Refer to the GHS Compiler documentation for a full description of the C implementation-defined behavior.</td></tr><tr xmlns=""><td>Use of assembler</td><td>Inline assembler code is used to adjust the stack pointer. Assembler files are used to handle stack initialization, exceptions and setjmp/longjmp operations.</td></tr><tr xmlns=""><td>Compiler</td><td>Green Hills Software, Compiler v2019.1.4: Ensure that ccarm.exe is on the path.</td></tr><tr xmlns=""><td>Compiler</td><td>Green Hills Software, Compiler v2021.1.4: Ensure that ccarm.exe is on the path.</td></tr><tr xmlns=""><td>Compiler</td><td>Green Hills Software, Compiler v2022.1.4: Ensure that ccarm.exe is on the path.</td></tr></table><h2>Notes</h2><p>

The MISRA deviations reported in the MISRA Deviations report are not considered to pose a risk to development as each deviation has been reviewed and subjected to suitable testing.
This means that RTA-OS library code featuring MISRA deviations does not require any mitigation actions to reduce development risk.
However user code which makes use of macros or RTA-OS API calls described in the RTA-OS header files Os.h should perform additional MISRA checking to assure the code is used correctly.
The locations in the MISRA Deviations report that result in code in Os.h are: Os_Safe_Cfg.h, OsMinusConfig.h, OsTrace.h, OsTargetTypes.h and Os_Cfg.h.
User code that includes target-specific header files such as Os_ConfigInterrupts.h or Os_DisableInterrupts.h that manipulate interrupt hardware should also be checked.

  </p><h2>Compliance Matrix</h2><table><thead><tr><th>Rule</th><th>Description</th><th>Check</th></tr></thead><tr xmlns=""><td>Dir 1.1</td><td>Any implementation-defined behaviour on which the output of the program depends shall be documented and understood.</td><td>Review of Toolchain Report.</td></tr><tr xmlns=""><td>Dir 2.1</td><td>All source files shall compile without any compilation errors</td><td>Compiler errors are detected in the RTA-OS build process via compiler exit status. These result in a build failure and no OS library gets generated.</td></tr><tr xmlns=""><td>Dir 3.1</td><td>All code shall be traceable to documented requirements</td><td>The RTA-OS development process is fully requirements-driven. The RReqs tracing tool is used to ensure complete tracing from customer requirement to detailed target requirement, test and test result. Target ports only ship with 100% traced, tested and passing requirements.</td></tr><tr xmlns=""><td>Dir 4.1</td><td>Run-time failures shall be minimized</td><td>Detailed testing.</td></tr><tr xmlns=""><td>Dir 4.2</td><td>All usage of assembly language should be documented</td><td>Review of Toolchain Report.</td></tr><tr xmlns=""><td>Dir 4.3</td><td>Assembly language shall be encapsulated and isolated</td><td>Review of Toolchain Report.</td></tr><tr xmlns=""><td>Dir 4.4</td><td>Sections of code should not be {commented out}</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Dir 4.5</td><td>Identifiers in the same name space with overlapping visibility should be typographically unambiguous</td><td>Code inspection.</td></tr><tr xmlns=""><td>Dir 4.6</td><td>typedefs that indicate size and signedness should be used in place of the basic numerical types</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Dir 4.7</td><td>If a function returns error information, then that error information shall be tested</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Dir 4.8</td><td>If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Dir 4.9</td><td>A function should be used in preference to a function-like macro where they are interchangeable</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Dir 4.10</td><td>Precautions shall be taken in order to prevent the contents of a header file being included more than once</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Dir 4.11</td><td>The validity of values passed to library functions shall be checked</td><td>Code inspection.</td></tr><tr xmlns=""><td>Dir 4.12</td><td>Dynamic memory allocation shall not be used</td><td>Code inspection.</td></tr><tr xmlns=""><td>Dir 4.13</td><td>Functions which are designed to provide operations on a resource should be called in an appropriate sequence</td><td>Code inspection.</td></tr><tr xmlns=""><td>Dir 4.14</td><td>The validity of values received from external sources shall be checked</td><td>Code inspection.</td></tr><tr xmlns=""><td>Dir 4.14</td><td>The validity of values received from external sources shall be checked</td><td>Code inspection. OS does not deal with files, environment variables, user input or communications. In extended mode, all API inputs are checked for validity.</td></tr><tr xmlns=""><td>Rule 1.1 </td><td>The program shall contain no violations of the standard C syntax and constraints, and shall not exceed the implementation's translation limits</td><td>Static analysis tool / code inspection.</td></tr><tr xmlns=""><td>Rule 1.2 </td><td>Language extensions should not be used</td><td>Static analysis tool</td></tr><tr xmlns=""><td>Rule 1.3 </td><td>There shall be no occurrence of undefined or critical unspecified behaviour</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 2.1 </td><td>A project shall not contain unreachable code</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 2.2 </td><td>There shall be no dead code</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 2.3 </td><td>A project should not contain unused type declarations</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 2.4 </td><td>A project should not contain unused tag declarations</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 2.5 </td><td>A project should not contain unused macro declarations</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 2.6 </td><td>A function should not contain unused label declarations</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 2.7 </td><td>There should be no unused parameters in functions</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 3.1 </td><td>The character sequences /* and // shall not be used within a comment</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 3.2 </td><td>Line-splicing shall not be used in // comments</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 4.1 </td><td>Octal and hexadecimal escape sequences shall be terminated</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 4.2 </td><td>Trigraphs should not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 5.1 </td><td>External identifiers shall be distinct</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 5.2 </td><td>Identifiers declared in the same scope and name space shall be distinct</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 5.3 </td><td>An identifier declared in an inner scope shall not hide an identifier declared in an outer scope</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 5.4 </td><td>Macro identifiers shall be distinct</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 5.5 </td><td>Identifiers shall be distinct from macro names</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 5.6 </td><td>A typedef name shall be a unique identifier</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 5.7 </td><td>A tag name shall be a unique identifier</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 5.8 </td><td>Identifiers that define objects or functions with external linkage shall be unique</td><td>Code inspection.</td></tr><tr xmlns=""><td>Rule 5.9 </td><td>Identifiers that define objects or functions with internal linkage should be unique</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 6.1 </td><td>Bit-fields shall only be declared with an appropriate type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 6.2 </td><td>Single-bit named bit fields shall not be of a signed type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 7.1 </td><td>Octal constants shall not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 7.2 </td><td>A {u} or {U} suffix shall be applied to all integer constants that are represented in an unsigned type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 7.3 </td><td>The lowercase character {l} shall not be used in a literal suffix</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 7.4 </td><td>A string literal shall not be assigned to an object unless the object's type is {pointer to const-qualified char}</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 8.1 </td><td>Types shall be explicitly specified</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 8.2 </td><td>Function types shall be in prototype form with named parameters</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 8.3 </td><td>All declarations of an object or function shall use the same names and type qualifiers</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 8.4 </td><td>A compatible declaration shall be visible when an object or function with external linkage is defined</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 8.5 </td><td>An external object or function shall be declared once in one and only one file</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 8.6 </td><td>An identifier with external linkage shall have exactly one external definition</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 8.7 </td><td>Functions and objects should not be defined with external linkage if they are referenced in only one translation unit</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 8.8 </td><td>The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 8.9 </td><td>An object should be defined at block scope if its identifier only appears in a single function</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 8.10 </td><td>An inline function shall be declared with the static storage class</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 8.11 </td><td>When an array with external linkage is declared, its size should be explicitly specified</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 8.12 </td><td>Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 8.13 </td><td>A pointer should point to a const-qualified type whenever possible</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 8.14 </td><td>The restrict type qualifier shall not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 9.1 </td><td>The value of an object with automatic storage duration shall not be read before it has been set</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 9.2 </td><td>The initializer for an aggregate or union shall be enclosed in braces</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 9.3 </td><td>Arrays shall not be partially initialized</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 9.4 </td><td>An element of an object shall not be initialized more than once</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 9.5 </td><td>Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 10.1 </td><td>Operands shall not be of an inappropriate essential type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 10.2 </td><td>Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 10.3 </td><td>The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 10.4 </td><td>Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 10.5 </td><td>The value of an expression should not be cast to an inappropriate essential type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 10.6 </td><td>The value of a composite expression shall not be assigned to an object with wider essential type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 10.7 </td><td>If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 10.8 </td><td>The value of a composite expression shall not be cast to a different essential type category or a wider essential type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 11.1 </td><td>Conversions shall not be performed between a pointer to a function and any other type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 11.2 </td><td>Conversions shall not be performed between a pointer to an incomplete type and any other type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 11.3 </td><td>A cast shall not be performed between a pointer to object type and a pointer to a different object type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 11.4</td><td>A conversion should not be performed between a pointer to object and an integer type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 11.5 </td><td>A conversion should not be performed from pointer to void into pointer to object</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 11.6 </td><td>A cast shall not be performed between pointer to void and an arithmetic type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 11.7 </td><td>A cast shall not be performed between pointer to object and a noninteger arithmetic type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 11.8 </td><td>A cast shall not remove any const or volatile qualification from the type pointed to by a pointer</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 11.9 </td><td>The macro NULL shall be the only permitted form of integer null pointer constant</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 12.1 </td><td>The precedence of operators within expressions should be made explicit</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 12.2 </td><td>The right hand operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 12.3 </td><td>The comma operator should not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 12.4 </td><td>Evaluation of constant expressions should not lead to unsigned integer wrap-around</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 12.5 </td><td>The sizeof operator shall not have an operand which is a function parameter declared as array of type</td><td>Static analysis tool (PCLint Warning 682).</td></tr><tr xmlns=""><td>Rule 13.1 </td><td>Initializer lists shall not contain persistent side effects</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 13.2 </td><td>The value of an expression and its persistent side effects shall be the same under all permitted evaluation orders</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 13.3 </td><td>A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 13.4 </td><td>The result of an assignment operator should not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 13.5 </td><td>The right hand operand of a logical &amp;&amp; or || operator shall not contain persistent side effects</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 13.6 </td><td>The operand of the sizeof operator shall not contain any expression which has potential side effects</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 14.1 </td><td>A loop counter shall not have essentially floating type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 14.2 </td><td>A for loop shall be well-formed</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 14.3 </td><td>Controlling expressions shall not be invariant</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 14.4 </td><td>The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 15.1 </td><td>The goto statement should not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 15.2 </td><td>The goto statement shall jump to a label declared later in the same function</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 15.3 </td><td>Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 15.4 </td><td>There should be no more than one break or goto statement used to terminate any iteration statement</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 15.5 </td><td>A function should have a single point of exit at the end</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 15.6 </td><td>The body of an iteration-statement or a selection-statement shall be a compound-statement</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 15.7 </td><td>All if … else if constructs shall be terminated with an else statement</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 16.1 </td><td>All switch statements shall be well-formed</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 16.2 </td><td>A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 16.3 </td><td>An unconditional break statement shall terminate every switch-clause</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 16.4 </td><td>Every switch statement shall have a default label</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 16.5 </td><td>A default label shall appear as either the first or the last switch label of a switch statement</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 16.6 </td><td>Every switch statement shall have at least two switch-clauses</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 16.7 </td><td>A switch-expression shall not have essentially Boolean type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 17.1 </td><td>The features of &lt;stdarg.h&gt; shall not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 17.2</td><td>Functions shall not call themselves, either directly or indirectly</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 17.3 </td><td>A function shall not be declared implicitly</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 17.4 </td><td>All exit paths from a function with non-void return type shall have an explicit return statement with an expression</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 17.5 </td><td>The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 17.6 </td><td>The declaration of an array parameter shall not contain the static keyword between the [ ]</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 17.7 </td><td>The value returned by a function having non-void return type shall be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 17.8 </td><td>A function parameter should not be modified</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 18.1 </td><td>A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 18.2 </td><td>Subtraction between pointers shall only be applied to pointers that address elements of the same array</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 18.3 </td><td>The relational operators &gt;, &gt;=, &lt; and &lt;= shall not be applied to objects of pointer type except where they point into the same object</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 18.4 </td><td>The +, -, += and -= operators should not be applied to an expression of pointer type</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 18.5 </td><td>Declarations should contain no more than two levels of pointer nesting</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 18.6 </td><td>The address of an object with automatic storage shall not be copied to another object that persists after the first object has ceased to exist</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 18.7 </td><td>Flexible array members shall not be declared</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 18.8 </td><td>Variable-length array types shall not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 19.1 </td><td>An object shall not be assigned or copied to an overlapping object</td><td>Code inspection.</td></tr><tr xmlns=""><td>Rule 19.2 </td><td>The union keyword should not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 20.1 </td><td>#include directives should only be preceded by preprocessor directives or comments</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 20.2 </td><td>The ', " or  characters and the /* or // character sequences shall not occur in a header file name</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 20.3 </td><td>The #include directive shall be followed by either a &lt;filename&gt; or "filename" sequence</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 20.4 </td><td>A macro shall not be defined with the same name as a keyword</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 20.5 </td><td>#undef should not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 20.6 </td><td>Tokens that look like a preprocessing directive shall not occur within a macro argument</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 20.7 </td><td>Expressions resulting from the expansion of macro parameters shall be enclosed in parentheses</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 20.8 </td><td>The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 20.9 </td><td>All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define'd before evaluation</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 20.10 </td><td>The # and ## preprocessor operators should not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 20.11 </td><td>A macro parameter immediately following a # operator shall not immediately be followed by a ## operator</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 20.12 </td><td>A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 20.13 </td><td>A line whose first token is # shall be a valid preprocessing directive</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 20.14 </td><td>All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if, #ifdef or #ifndef directive to which they are related</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 21.1 </td><td>#define and #undef shall not be used on a reserved identifier or reserved macro name</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 21.2 </td><td>A reserved identifier or macro name shall not be declared</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 21.3 </td><td>The memory allocation and deallocation functions of &lt;stdlib.h&gt; shall not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 21.4 </td><td>The standard header file &lt;setjmp.h&gt; shall not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 21.5 </td><td>The standard header file &lt;signal.h&gt; shall not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 21.6 </td><td>The Standard Library input/output functions shall not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 21.7 </td><td>The atof, atoi, atol and atoll functions of &lt;stdlib.h&gt; shall not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 21.8 </td><td>The library functions abort, exit and system of &lt;stdlib.h&gt; shall not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 21.9 </td><td>The library functions bsearch and qsort of &lt;stdlib.h&gt; shall not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 21.10 </td><td>The Standard Library time and date functions shall not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 21.11 </td><td>The standard header file &lt;tgmath.h&gt; shall not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 21.12 </td><td>The exception handling features of &lt;fenv.h&gt; should not be used</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 21.13 </td><td>Any value passed to a function in ctype.h shall be representable as an unsigned char or be the value EOF</td><td>Code inspection. ctype.h is not used in the OS.</td></tr><tr xmlns=""><td>Rule 21.14 </td><td>The Standard Library function memcmp shall not be used to compare null terminated strings</td><td>Code inspection. memcmp is not used in the OS. Strings are not used in the OS.</td></tr><tr xmlns=""><td>Rule 21.15 </td><td>The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers to qualified or unqualified versions of compatible types</td><td>Code inspection. memcpy, memmove and memcmp are not used in the OS.</td></tr><tr xmlns=""><td>Rule 21.16 </td><td>The pointer arguments to the Standard Library function memcmp shall pointer to either a pointer type, an essentially signed type, an essentially unsigned type, and essentially Boolean type or an essentially enum type</td><td>Code inspection. memcmp is not used in the OS.</td></tr><tr xmlns=""><td>Rule 21.17 </td><td>Use of the string handling functions from string.h shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters</td><td>Code inspection. string.h is not used in the OS. Strings are not used in the OS.</td></tr><tr xmlns=""><td>Rule 21.18 </td><td>The size_t argument passed to any function in string.h shall have an appropriate value</td><td>Code inspection. string.h is not used in the OS.</td></tr><tr xmlns=""><td>Rule 21.19 </td><td>The pointers returned by the standard library functions localeconv, getenv, setlocale or, strerror shall only be used as if they have pointer to const-qualified type</td><td>Code inspection. The standard library is not used in the OS.</td></tr><tr xmlns=""><td>Rule 21.20 </td><td>The pointer returned by the standard library functions asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or strerror shall not be used following a subsequent call to the same function</td><td>Code inspection. The standard library is not used in the OS.</td></tr><tr xmlns=""><td>Rule 22.1 </td><td>All resources obtained dynamically by means of Standard Library functions shall be explicitly released</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 22.2 </td><td>A block of memory shall only be freed if it was allocated by means of a Standard Library function</td><td>Static analysis tool.</td></tr><tr xmlns=""><td>Rule 22.3 </td><td>The same file shall not be open for read and write access at the same time on different streams</td><td>Code inspection (There are no File operations in AUTOSAR classic).</td></tr><tr xmlns=""><td>Rule 22.4 </td><td>There shall be no attempt to write to a stream which has been opened as read-only</td><td>Code inspection (There are no File operations in AUTOSAR classic).</td></tr><tr xmlns=""><td>Rule 22.5 </td><td>A pointer to a FILE object shall not be dereferenced</td><td>Code inspection (There are no File operations in AUTOSAR classic).</td></tr><tr xmlns=""><td>Rule 22.6 </td><td>The value of a pointer to a FILE shall not be used after the associated stream has been closed</td><td>Code inspection (There are no File operations in AUTOSAR classic).</td></tr><tr xmlns=""><td>Rule 22.7 </td><td>The macro EOF shall only be compared with the unmodified return value from any standard library function capable of returning EOF.</td><td>Code inspection. The standard library is not used in the OS.</td></tr><tr xmlns=""><td>Rule 22.8 </td><td>The value of errno shall be set to zero prior to a call to an errno-setting-function</td><td>Code inspection. The standard library is not used in the OS.</td></tr><tr xmlns=""><td>Rule 22.9 </td><td>The value of errno shall be tested against zero after calling an errno-setting-function.</td><td>Code inspection. The standard library is not used in the OS.</td></tr><tr xmlns=""><td>Rule 22.10 </td><td>The value of errno shall only be tested when the last function to be called was an errno-setting-function</td><td>Code inspection. The standard library is not used in the OS.</td></tr></table><h2>Deviation Report</h2><h3 xmlns="">MISRA 2012 Dir 4.9</h3><p xmlns="">A function should be used in preference to a function-like macro where they are interchangeable.</p><table xmlns=""><thead><tr><th>Location</th><th>Code</th><th>Rationale</th></tr></thead><tr><td>IKernel.h</td><td>Os_Call_StackOverrunHook, Os_Call_TimeOverrunHook</td><td>The function-like macros Os_Call_StackOverrunHook, Os_Call_TimeOverrunHook are used to inject code inline in a way that is portable across different compilers.</td></tr><tr><td>Os_Safe_Cfg.h</td><td>OS_TICKS2*</td><td>The function-like macro OS_TICKS2* is required by AUTOSAR to be a macro.</td></tr><tr><td>OsMinusConfig.h</td><td>OSMEMORY_IS_READABLE, OSMEMORY_IS_WRITEABLE, OSMEMORY_IS_EXECUTABLE, OSMEMORY_IS_...</td><td>The function-like macros OSMEMORY_IS_READABLE, OSMEMORY_IS_WRITEABLE, OSMEMORY_IS_EXECUTABLE, OSMEMORY_IS_STACKSPACE are specified by AUTOSAR.</td></tr><tr><td>OsMinusConfig.h</td><td>DeclareEvent</td><td>The function-like macro DeclareEvent is specified by AUTOSAR.</td></tr><tr><td>OsMinusConfig.h</td><td>OS_ISRTYPE_TO_INDEX</td><td>The function-like macro OS_ISRTYPE_TO_INDEX is used to return a compile-time constant value in the most efficient manner.</td></tr><tr><td>OsMinusConfig.h</td><td>OS_INDEX_TO_ISRTYPE</td><td>The function-like macro OS_INDEX_TO_ISRTYPE is used to return a compile-time constant value in the most efficient manner.</td></tr><tr><td>OsMinusConfig.h</td><td>ISR, DeclareISR</td><td>The function-like macros ISR, DeclareISR are specified by AUTOSAR.</td></tr><tr><td>OsMinusConfig.h</td><td>OS_TASKTYPE_TO_INDEX</td><td>The function-like macro OS_TASKTYPE_TO_INDEX is used to return a compile-time constant value in the most efficient manner.</td></tr><tr><td>OsMinusConfig.h</td><td>OS_INDEX_TO_TASKTYPE</td><td>The function-like macro OS_INDEX_TO_TASKTYPE is used to return a compile-time constant value in the most efficient manner.</td></tr><tr><td>OsMinusConfig.h</td><td>TASK, DeclareTask</td><td>The function-like macros TASK, DeclareTask are specified by AUTOSAR.</td></tr><tr><td>OsMinusConfig.h</td><td>DeclareResource</td><td>The function-like macro DeclareResource is specified by AUTOSAR.</td></tr><tr><td>OsMinusConfig.h</td><td>DeclareAlarm, ALARMCALLBACK</td><td>The function-like macros DeclareAlarm, ALARMCALLBACK are specified by AUTOSAR.</td></tr><tr><td>OsMinusConfig.h</td><td>DeclareCounter</td><td>The function-like macro DeclareCounter is specified by AUTOSAR.</td></tr><tr><td>OsMinusConfig.h</td><td>DeclareScheduleTable</td><td>The function-like macro DeclareScheduleTable is specified by AUTOSAR.</td></tr><tr><td>OsMinusConfig.h</td><td>OSError_*</td><td>The function-like macro OSError_* is specified by AUTOSAR.</td></tr><tr><td>OsMinusConfig.h</td><td>OSErrorGetServiceId</td><td>The function-like macro OSErrorGetServiceId is specified by AUTOSAR.</td></tr><tr><td>OsMinusConfig.h</td><td>Schedule</td><td>The function-like macro Schedule is used to inject code inline in a way that is portable across different compilers.</td></tr><tr><td>OsMinusConfig.h</td><td>ChainTask</td><td>The function-like macro ChainTask is used to inject code inline in a way that is portable across different compilers.</td></tr><tr><td>OsMinusConfig.h</td><td>TerminateTask</td><td>The function-like macro TerminateTask is used to inject code inline in a way that is portable across different compilers.</td></tr><tr><td>OsMinusConfig.h</td><td>CheckObjectOwnership, CheckObjectAccess</td><td>The function-like macros CheckObjectOwnership, CheckObjectAccess are wrappers that are used to enforce the parameter type-cast on to Os_AnyType without user-code having to do this itself.</td></tr><tr><td>OsMinusConfig.h</td><td>CheckTaskMemoryAccess, CheckISRMemoryAccess</td><td>The function-like macros CheckTaskMemoryAccess, CheckISRMemoryAccess are wrappers that are used to enforce the parameter type-cast on to MemoryStartAddressType without user-code having to do this itself.</td></tr><tr><td>OsMinusConfig.h</td><td>StartOS</td><td>The function-like macro StartOS is used to inject code inline in a way that is portable across different compilers.</td></tr><tr><td>OsMinusConfig.h</td><td>GetCoreID</td><td>The function-like macro GetCoreID is used to inject code inline in a way that is portable across different compilers.</td></tr><tr><td>OsTrace.h</td><td>OS_TRACE*, Os_Log*, Os_Set*, Os_Clear*, Os_Trigger*, OSTRACE_*</td><td>The function-like macros OS_TRACE*, Os_Log*, Os_Set*, Os_Clear*, Os_Trigger*, OSTRACE_* are used so that tracing code can be conditionally included.</td></tr><tr><td>OsTrace.h</td><td>Os_*Trace*, Os_*Trigger*</td><td>The function-like macros Os_*Trace*, Os_*Trigger* are used to stub out tracing code.</td></tr><tr><td>OsTargetTypes.h</td><td>/* CAT1_ISR, CAT1_TRAP, OS_MAIN, OS_CLZ, OS_GETSP, OS_GETCPSR, OS_SETCPSR, OS_SVC...</td><td>These function-like macros are used for code portability. They can not be efficiently implemented as functions across all target ports.</td></tr><tr><td>Os_Cfg.h</td><td>OS_TPL_FOR_TASK, OS_IMASK_FOR_TASK</td><td>The function-like macros OS_TPL_FOR_TASK, OS_IMASK_FOR_TASK are part of the required API.</td></tr><tr><td>Os_Cfg.h</td><td>OS_CORE_FOR_TASK</td><td>The function-like macro OS_CORE_FOR_TASK is used to return a compile-time constant value in the most efficient manner.</td></tr><tr><td>Os_Cfg.h</td><td>OS_CORE_FOR_ISR</td><td>The function-like macro OS_CORE_FOR_ISR is used to return a compile-time constant value in the most efficient manner.</td></tr><tr><td>Os_Cfg.h</td><td>OS_IMASK_FOR_ISR</td><td>The function-like macro OS_IMASK_FOR_ISR is part of the required API.</td></tr><tr><td>Os_Cfg.h</td><td>LogTrace*, LogTaskTrace*, LogInterval*</td><td>The function-like macros LogTrace*, LogTaskTrace*, LogInterval* are used so that tracing code can be conditionally included.</td></tr><tr><td>Os_ConfigInterrupts.h</td><td>/* Os_Enable_*, Os_Disable_*, Os_Clear_*, Os_IsPending_*, Os_IsEnabled_*, Os_Trig...</td><td>Requirements dictate that these function-like macros must exist</td></tr></table><h3 xmlns="">MISRA 2012 Rule 1.3</h3><p xmlns="">There shall be no occurrence of undefined or critical unspecified behaviour.</p><table xmlns=""><thead><tr><th>Location</th><th>Code</th><th>Rationale</th></tr></thead><tr><td>Os_Cfg.h</td><td>/* [MISRA 2012 Rule 20.10] */ /*lint -esym(9024, Os_LogCat1ISRStart) */ \ #define...</td><td>The Os_LogCat1ISRStart(x) needs to use ## twice: once to check validity, once to use value.</td></tr><tr><td>Os_Cfg.h</td><td>/* [MISRA 2012 Rule 20.10] */ /*lint -esym(9024, Os_LogCat1ISREnd) */ \ #define O...</td><td>The Os_LogCat1ISREnd(x) needs to use ## twice: once to check validity, once to use value.</td></tr></table><h3 xmlns="">MISRA 2012 Rule 11.3</h3><p xmlns="">A cast shall not be performed between a pointer to object type and a pointer to a different object type.</p><table xmlns=""><thead><tr><th>Location</th><th>Code</th><th>Rationale</th></tr></thead><tr><td>GetResource.c</td><td>ResID-&gt;dynamic-&gt;locker = (INVALID_ISR != Os_RunningISR) ? (TaskType)Os_RunningISR...</td><td>This is an ORTI-related cast. The ORTI file contains a correct decoding of the locker.</td></tr><tr><td>Os_Cfg.c</td><td>Os_memclr((uint8 *)&amp;Os_ControlledCoreInfo[0U], sizeof(Os_ControlledCoreInfo[0U])/...</td><td>&amp;Os_ControlledCoreInfo[0U] can be safely reduced to a uint8 pointer for use in Os_memclr.</td></tr><tr><td>Os_Cfg.c</td><td>Os_memclr((uint8 *)&amp;Os_ControlledCoreInfo[1U], sizeof(Os_ControlledCoreInfo[1U])/...</td><td>&amp;Os_ControlledCoreInfo[1U] can be safely reduced to a uint8 pointer for use in Os_memclr.</td></tr><tr><td>Os_Cfg.c</td><td>Os_memclr((uint8 *)Os_dyn_tasks, sizeof(Os_dyn_tasks)/sizeof(uint8));</td><td>Os_dyn_tasks can be safely reduced to a uint8 pointer for use in Os_memclr.</td></tr><tr><td>Os_Cfg.c</td><td>Os_memclr((uint8 *)Os_dyn_isrs, sizeof(Os_dyn_isrs)/sizeof(uint8));</td><td>Os_dyn_isrs can be safely reduced to a uint8 pointer for use in Os_memclr.</td></tr><tr><td>Os_Cfg.c</td><td>Os_memclr((uint8 *)Os_dyn_resources, sizeof(Os_dyn_resources)/sizeof(uint8));</td><td>Os_dyn_resources can be safely reduced to a uint8 pointer for use in Os_memclr.</td></tr><tr><td>Os_Cfg.c</td><td>Os_memclr((uint8 *)Os_dyn_appstate, sizeof(Os_dyn_appstate)/sizeof(uint8));</td><td>Os_dyn_appstate can be safely reduced to a uint8 pointer for use in Os_memclr.</td></tr><tr><td>Os_Cfg.c</td><td /><td>The Os_TraceAppendData() API serializes data. It takes account of alignment issues internally.</td></tr></table><h3 xmlns="">MISRA 2012 Rule 11.4/11.6</h3><p xmlns="">A conversion should not be performed between a pointer to object and an integer type. A cast shall not be performed between pointer to void and an arithmetic type.</p><table xmlns=""><thead><tr><th>Location</th><th>Code</th><th>Rationale</th></tr></thead><tr><td>OsMinusConfig.h</td><td>#define OSError_ActivateTask_TaskID() ((TaskType)(Os_ErrorInformation.service_par...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_AdvanceCounter_CounterID() ((CounterType)(Os_ErrorInformation....</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_CancelAlarm_AlarmID() ((AlarmType)(Os_ErrorInformation.service_pa...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_CallTrustedFunction_FunctionIndex() ((TrustedFunctionIndexType)(O...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_CallTrustedFunction_FunctionParams() ((TrustedFunctionParameterRe...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ChainTask_TaskID() ((TaskType)(Os_ErrorInformation.service_param1...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ClearEvent_Mask() ((EventMaskType)(Os_ErrorInformation.service_pa...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ControlIdle_CoreID() ((CoreIdType)(Os_ErrorInformation.service_pa...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ControlIdle_IdleMode() ((IdleModeType)(Os_ErrorInformation.servic...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetAlarm_AlarmID() ((AlarmType)(Os_ErrorInformation.service_param...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetAlarm_Tick() ((TickRefType)(Os_ErrorInformation.service_param2...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetAlarmBase_AlarmID() ((AlarmType)(Os_ErrorInformation.service_p...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetAlarmBase_Info() ((AlarmBaseRefType)(Os_ErrorInformation.servi...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetCounterValue_CounterID() ((CounterType)(Os_ErrorInformation.se...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetCounterValue_Value() ((TickRefType)(Os_ErrorInformation.servic...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetElapsedCounterValue_CounterID() ((CounterType)(Os_ErrorInforma...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetElapsedCounterValue_Value() ((TickRefType)(Os_ErrorInformation...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetElapsedCounterValue_ElapsedValue() ((TickRefType)(Os_ErrorInfo...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetEvent_TaskID() ((TaskType)(Os_ErrorInformation.service_param1)...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetEvent_Mask() ((EventMaskRefType)(Os_ErrorInformation.service_p...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetResource_ResID() ((ResourceType)(Os_ErrorInformation.service_p...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetScheduleTableStatus_ScheduleTableID() ((ScheduleTableType)(Os_...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetScheduleTableStatus_ScheduleStatus() ((ScheduleTableStatusRefT...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetTaskID_TaskID() ((TaskRefType)(Os_ErrorInformation.service_par...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetTaskState_TaskID() ((TaskType)(Os_ErrorInformation.service_par...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetTaskState_State() ((TaskStateRefType)(Os_ErrorInformation.serv...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_IncrementCounter_CounterID() ((CounterType)(Os_ErrorInformation.s...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_NextScheduleTable_ScheduleTableID_From() ((ScheduleTableType)(Os_...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_NextScheduleTable_ScheduleTableID_To() ((ScheduleTableType)(Os_Er...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_GetISRMaxExecutionTime_ISRID() ((ISRType)(Os_ErrorInformation....</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_GetTaskMaxExecutionTime_TaskID() ((TaskType)(Os_ErrorInformati...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_ResetISRMaxExecutionTime_ISRID() ((ISRType)(Os_ErrorInformatio...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_ResetTaskMaxExecutionTime_TaskID() ((TaskType)(Os_ErrorInforma...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_GetTaskElapsedTime_TaskID() ((TaskType)(Os_ErrorInformation.se...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_GetISRElapsedTime_ISRID() ((ISRType)(Os_ErrorInformation.servi...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_GetIdleElapsedTime_IdleID() ((Os_IdleType)(Os_ErrorInformation...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_ResetTaskElapsedTime_TaskID() ((TaskType)(Os_ErrorInformation....</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_ResetISRElapsedTime_ISRID() ((ISRType)(Os_ErrorInformation.ser...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_ResetIdleElapsedTime_IdleID() ((Os_IdleType)(Os_ErrorInformati...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_GetStackSize_Base() ((Os_StackValueType)(Os_ErrorInformation.s...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_GetStackSize_Sample() ((Os_StackValueType)(Os_ErrorInformation...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_GetISRMaxStackUsage_ISRID() ((ISRType)(Os_ErrorInformation.ser...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_GetTaskMaxStackUsage_TaskID() ((TaskType)(Os_ErrorInformation....</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_ResetISRMaxStackUsage_ISRID() ((ISRType)(Os_ErrorInformation.s...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_ResetTaskMaxStackUsage_TaskID() ((TaskType)(Os_ErrorInformatio...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ReleaseResource_ResID() ((ResourceType)(Os_ErrorInformation.servi...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_SetEvent_TaskID() ((TaskType)(Os_ErrorInformation.service_param1)...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_SetEvent_Mask() ((EventMaskType)(Os_ErrorInformation.service_para...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_SetAbsAlarm_AlarmID() ((AlarmType)(Os_ErrorInformation.service_pa...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_SetAbsAlarm_start() ((TickType)(Os_ErrorInformation.service_param...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_SetAbsAlarm_cycle() ((TickType)(Os_ErrorInformation.service_param...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_SetRelAlarm_AlarmID() ((AlarmType)(Os_ErrorInformation.service_pa...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_SetRelAlarm_increment() ((TickType)(Os_ErrorInformation.service_p...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_SetRelAlarm_cycle() ((TickType)(Os_ErrorInformation.service_param...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_StartScheduleTableAbs_ScheduleTableID() ((ScheduleTableType)(Os_E...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_StartScheduleTableAbs_Start() ((TickType)(Os_ErrorInformation.ser...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_StartScheduleTableRel_ScheduleTableID() ((ScheduleTableType)(Os_E...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_StartScheduleTableRel_Offset() ((TickType)(Os_ErrorInformation.se...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_StartScheduleTableSynchron_ScheduleTableID() ((ScheduleTableType)...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_SyncScheduleTable_ScheduleTableID() ((ScheduleTableType)(Os_Error...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_SyncScheduleTable_Value() ((TickType)(Os_ErrorInformation.service...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_SyncScheduleTableRel_ScheduleTableID() ((ScheduleTableType)(Os_Er...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_SyncScheduleTableRel_RelativeValue() ((SignedTickType)(Os_ErrorIn...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_SetScheduleTableAsync_ScheduleTableID() ((ScheduleTableType)(Os_E...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_StopScheduleTable_ScheduleTableID() ((ScheduleTableType)(Os_Error...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_WaitEvent_Mask() ((EventMaskType)(Os_ErrorInformation.service_par...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_EnableInterruptSource_ISRID() ((ISRType)(Os_ErrorInformation.serv...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_EnableInterruptSource_ClearPending() ((boolean)(Os_ErrorInformati...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_DisableInterruptSource_ISRID() ((ISRType)(Os_ErrorInformation.ser...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ClearPendingInterrupt_ISRID() ((ISRType)(Os_ErrorInformation.serv...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ModifyPeripheral32_Area() ((AreaIdType)(Os_ErrorInformation.servi...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ModifyPeripheral32_Address() ((Os_uint32RefType)(Os_ErrorInformat...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ReadPeripheral32_Area() ((AreaIdType)(Os_ErrorInformation.service...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ReadPeripheral32_Address() ((Os_uint32ConstRefType)(Os_ErrorInfor...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ReadPeripheral32_ReadValue() ((Os_uint32RefType)(Os_ErrorInformat...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_WritePeripheral32_Area() ((AreaIdType)(Os_ErrorInformation.servic...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_WritePeripheral32_Address() ((Os_uint32RefType)(Os_ErrorInformati...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_WritePeripheral32_WriteValue() ((uint32)(Os_ErrorInformation.serv...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ModifyPeripheral16_Area() ((AreaIdType)(Os_ErrorInformation.servi...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ModifyPeripheral16_Address() ((Os_uint16RefType)(Os_ErrorInformat...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ReadPeripheral16_Area() ((AreaIdType)(Os_ErrorInformation.service...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ReadPeripheral16_Address() ((Os_uint16ConstRefType)(Os_ErrorInfor...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ReadPeripheral16_ReadValue() ((Os_uint16RefType)(Os_ErrorInformat...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_WritePeripheral16_Area() ((AreaIdType)(Os_ErrorInformation.servic...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_WritePeripheral16_Address() ((Os_uint16RefType)(Os_ErrorInformati...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_WritePeripheral16_WriteValue() ((uint16)(Os_ErrorInformation.serv...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_GetTaskActivationTime_TaskID() ((TaskType)(Os_ErrorInformation...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_Os_GetTaskActivationTime_Value() ((Os_StopwatchTickRefType)(Os_Er...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ModifyPeripheral8_Area() ((AreaIdType)(Os_ErrorInformation.servic...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ModifyPeripheral8_Address() ((Os_uint8RefType)(Os_ErrorInformatio...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ReadPeripheral8_Area() ((AreaIdType)(Os_ErrorInformation.service_...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ReadPeripheral8_Address() ((Os_uint8ConstRefType)(Os_ErrorInforma...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ReadPeripheral8_ReadValue() ((Os_uint8RefType)(Os_ErrorInformatio...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_WritePeripheral8_Area() ((AreaIdType)(Os_ErrorInformation.service...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_WritePeripheral8_Address() ((Os_uint8RefType)(Os_ErrorInformation...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_WritePeripheral8_WriteValue() ((uint8)(Os_ErrorInformation.servic...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetApplicationState_Application() ((ApplicationType)(Os_ErrorInfo...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetApplicationState_Value() ((ApplicationStateRefType)(Os_ErrorIn...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_GetSpinlock_SpinlockId() ((SpinlockIdType)(Os_ErrorInformation.se...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_ReleaseSpinlock_SpinlockId() ((SpinlockIdType)(Os_ErrorInformatio...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_TryToGetSpinlock_SpinlockId() ((SpinlockIdType)(Os_ErrorInformati...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>OsMinusConfig.h</td><td>#define OSError_TryToGetSpinlock_Success() ((Os_TryToGetSpinlockRefType)(Os_Error...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values from Os_BiggestType.</td></tr><tr><td>ActivateTask.c</td><td>Os_ErrorLog(api_retval, OSServiceId_ActivateTask, (Os_BiggestType)TaskID, (Os_Big...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values to Os_BiggestType.</td></tr><tr><td>AllowAccess.c</td><td>Os_ErrorLog(api_retval, OSServiceId_AllowAccess, (Os_BiggestType)0, (Os_BiggestTy...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values to Os_BiggestType.</td></tr><tr><td>CallTrustedFunction.c</td><td>Os_ErrorLog(api_retval, OSServiceId_CallTrustedFunction, (Os_BiggestType)Function...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values to Os_BiggestType.</td></tr><tr><td>ChainTask.c</td><td>Os_ErrorLog(api_retval, OSServiceId_ChainTask, (Os_BiggestType)TaskID, (Os_Bigges...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values to Os_BiggestType.</td></tr><tr><td>GetApplicationState.c</td><td>Os_ErrorLog(api_retval, OSServiceId_GetApplicationState, (Os_BiggestType)Applicat...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values to Os_BiggestType.</td></tr><tr><td>Os_Cfg_KL.c</td><td>, (Os_BiggestType)TaskID,(Os_BiggestType)0U,(Os_BiggestType)0U</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values to Os_BiggestType.</td></tr><tr><td>Os_Cfg_KL.c</td><td>, (Os_BiggestType)TaskID,(Os_BiggestType)0U,(Os_BiggestType)0U</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values to Os_BiggestType.</td></tr><tr><td>Os_Cfg_KL.c</td><td>, (Os_BiggestType)TaskID,(Os_BiggestType)0U,(Os_BiggestType)0U</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values to Os_BiggestType.</td></tr><tr><td>Os_Cfg_KL.c</td><td>, (Os_BiggestType)TaskID,(Os_BiggestType)0U,(Os_BiggestType)0U</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values to Os_BiggestType.</td></tr><tr><td>SetScheduleTableAsync.c</td><td>Os_ErrorLog(api_retval, OSServiceId_SetScheduleTableAsync, (Os_BiggestType)Schedu...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values to Os_BiggestType.</td></tr><tr><td>StartScheduleTableSynchron.c</td><td>Os_ErrorLog(api_retval, OSServiceId_StartScheduleTableSynchron, (Os_BiggestType)S...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values to Os_BiggestType.</td></tr><tr><td>SyncScheduleTable.c</td><td>Os_ErrorLog(api_retval, OSServiceId_SyncScheduleTable, (Os_BiggestType)ScheduleTa...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values to Os_BiggestType.</td></tr><tr><td>SyncScheduleTableRel.c</td><td>Os_ErrorLog(api_retval, OSServiceId_SyncScheduleTableRel, (Os_BiggestType)Schedul...</td><td>When ErrorLog is configured to record API values, it is necessary to cast all values to Os_BiggestType.</td></tr></table><h3 xmlns="">MISRA 2012 Rule 11.5</h3><p xmlns="">A conversion should not be performed from pointer to void into pointer to object.</p><table xmlns=""><thead><tr><th>Location</th><th>Code</th><th>Rationale</th></tr></thead><tr><td>CheckObjectAccess.c</td><td>TaskType o = (TaskType)Object;</td><td>Pointer conversion forced by API.</td></tr><tr><td>CheckObjectAccess.c</td><td>ISRType o = (ISRType)Object;</td><td>Pointer conversion forced by API.</td></tr><tr><td>CheckObjectAccess.c</td><td>ResourceType o = (ResourceType)Object;</td><td>Pointer conversion forced by API.</td></tr><tr><td>CheckObjectAccess.c</td><td>CounterType o = (CounterType)Object;</td><td>Pointer conversion forced by API.</td></tr><tr><td>CheckObjectAccess.c</td><td>ScheduleTableType o = (ScheduleTableType)Object;</td><td>Pointer conversion forced by API.</td></tr><tr><td>CheckObjectOwnership.c</td><td>TaskType o = (TaskType)Object;</td><td>Pointer conversion forced by API.</td></tr><tr><td>CheckObjectOwnership.c</td><td>ISRType o = (ISRType)Object;</td><td>Pointer conversion forced by API.</td></tr><tr><td>CheckObjectOwnership.c</td><td>CounterType o = (CounterType)Object;</td><td>Pointer conversion forced by API.</td></tr><tr><td>CheckObjectOwnership.c</td><td>ScheduleTableType o = (ScheduleTableType)Object;</td><td>Pointer conversion forced by API.</td></tr></table><h3 xmlns="">MISRA 2012 Rule 12.3</h3><p xmlns="">The comma operator should not be used.</p><table xmlns=""><thead><tr><th>Location</th><th>Code</th><th>Rationale</th></tr></thead><tr><td>Os_ConfigInterrupts.h</td><td>#define Os_DisableAllConfiguredInterrupts_Core0() ( (OS_R52_GICR0_ICENABLER[0] = ...</td><td>Commas are used to allow macro to operate syntactically as expected by API.</td></tr><tr><td>Os_ConfigInterrupts.h</td><td>#define Os_EnableAllConfiguredInterrupts_Core0() ( (OS_R52_GICR0_ISENABLER[0] = 0...</td><td>Commas are used to allow macro to operate syntactically as expected by API.</td></tr><tr><td>Os_ConfigInterrupts.h</td><td>#define Os_DisableAllConfiguredInterrupts_Core1() ( (OS_R52_GICD_ICENABLER[9] = 0...</td><td>Commas are used to allow macro to operate syntactically as expected by API.</td></tr><tr><td>Os_ConfigInterrupts.h</td><td>#define Os_EnableAllConfiguredInterrupts_Core1() ( (OS_R52_GICD_ISENABLER[9] = 0x...</td><td>Commas are used to allow macro to operate syntactically as expected by API.</td></tr></table><h3 xmlns="">MISRA 2012 Rule 15.1</h3><p xmlns="">The goto statement should not be used.</p><table xmlns=""><thead><tr><th>Location</th><th>Code</th><th>Rationale</th></tr></thead><tr><td>ActivateTask.c</td><td /><td>goto is used in ActivateTask for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>AdvanceCounter.c</td><td /><td>goto is used in AdvanceCounter for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>AllowAccess.c</td><td /><td>goto is used in AllowAccess for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>CallTrustedFunction.c</td><td /><td>goto is used in CallTrustedFunction for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>CancelAlarm.c</td><td /><td>goto is used in CancelAlarm for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ChainTask.c</td><td /><td>goto is used in ChainTask for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>CheckISRMemoryAccess.c</td><td /><td>goto is used in CheckISRMemoryAccess for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>CheckObjectAccess.c</td><td /><td>goto is used in CheckObjectAccess for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>CheckObjectOwnership.c</td><td /><td>goto is used in CheckObjectOwnership for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>CheckTaskMemoryAccess.c</td><td /><td>goto is used in CheckTaskMemoryAccess for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ClearEvent.c</td><td /><td>goto is used in ClearEvent for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ControlIdle.c</td><td /><td>goto is used in ControlIdle for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>DisableAllInterrupts.c</td><td /><td>goto is used in DisableAllInterrupts for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ElapsedTime.c</td><td /><td>goto is used in GetElapsedTime for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ElapsedTime.c</td><td /><td>goto is used in GetTaskElapsedTime for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ElapsedTime.c</td><td /><td>goto is used in ResetTaskElapsedTime for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ElapsedTime.c</td><td /><td>goto is used in GetISRElapsedTime for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ElapsedTime.c</td><td /><td>goto is used in ResetISRElapsedTime for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ElapsedTime.c</td><td /><td>goto is used in GetIdleElapsedTime for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ElapsedTime.c</td><td /><td>goto is used in ResetIdleElapsedTime for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>EnableAllInterrupts.c</td><td /><td>goto is used in EnableAllInterrupts for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetActiveApplicationMode.c</td><td /><td>goto is used in GetActiveApplicationMode for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetAlarm.c</td><td /><td>goto is used in GetAlarm for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetAlarmBase.c</td><td /><td>goto is used in GetAlarmBase for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetApplicationID.c</td><td /><td>goto is used in GetApplicationID for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetApplicationState.c</td><td /><td>goto is used in GetApplicationState for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetCounterValue.c</td><td /><td>goto is used in GetCounterValue for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetCurrentApplicationID.c</td><td /><td>goto is used in GetCurrentApplicationID for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetElapsedCounterValue.c</td><td /><td>goto is used in GetElapsedCounterValue for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetEvent.c</td><td /><td>goto is used in GetEvent for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetExecutionTime.c</td><td /><td>goto is used in GetExecutionTime for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetISRID.c</td><td /><td>goto is used in GetISRID for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetIsrMaxExecutionTime.c</td><td /><td>goto is used in GetISRMaxExecutionTime for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetIsrMaxStackUsage.c</td><td /><td>goto is used in GetISRMaxStackUsage for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetNumberOfActivatedCores.c</td><td /><td>goto is used in GetNumberOfActivatedCores for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetResource.c</td><td /><td>goto is used in GetResource for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetScheduleTableStatus.c</td><td /><td>goto is used in GetScheduleTableStatus for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetSpinlock.c</td><td /><td>goto is used in GetSpinlock for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetStackSize.c</td><td /><td>goto is used in GetStackSize for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetStackUsage.c</td><td /><td>goto is used in GetStackUsage for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetStackValue.c</td><td /><td>goto is used in GetStackValue for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetTaskActivationTime.c</td><td /><td>goto is used in GetTaskActivationTime for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetTaskID.c</td><td /><td>goto is used in GetTaskID for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetTaskMaxExecutionTime.c</td><td /><td>goto is used in GetTaskMaxExecutionTime for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetTaskMaxStackUsage.c</td><td /><td>goto is used in GetTaskMaxStackUsage for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetTaskState.c</td><td /><td>goto is used in GetTaskState for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>GetVersionInfo.c</td><td /><td>goto is used in GetVersionInfo for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>IncrementCounter.c</td><td /><td>goto is used in IncrementCounter for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>InterruptSource.c</td><td /><td>goto is used in EnableInterruptSource for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>InterruptSource.c</td><td /><td>goto is used in DisableInterruptSource for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>InterruptSource.c</td><td /><td>goto is used in ClearPendingInterrupt for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ModifyPeripheral.c</td><td /><td>goto is used in ModifyPeripheral8 for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ModifyPeripheral.c</td><td /><td>goto is used in ModifyPeripheral16 for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ModifyPeripheral.c</td><td /><td>goto is used in ModifyPeripheral32 for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>NextScheduleTable.c</td><td /><td>goto is used in NextScheduleTable for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>Os_GetCurrentIMask.c</td><td /><td>goto is used in GetCurrentIMask for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>Os_GetCurrentTPL.c</td><td /><td>goto is used in GetCurrentTPL for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>Os_ScheduleQ.c</td><td /><td>goto is used in ScheduleQ for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ReadPeripheral.c</td><td /><td>goto is used in ReadPeripheral8 for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ReadPeripheral.c</td><td /><td>goto is used in ReadPeripheral16 for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ReadPeripheral.c</td><td /><td>goto is used in ReadPeripheral32 for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ReleaseResource.c</td><td /><td>goto is used in ReleaseResource for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ReleaseSpinlock.c</td><td /><td>goto is used in ReleaseSpinlock for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ResetIsrMaxExecutionTime.c</td><td /><td>goto is used in ResetISRMaxExecutionTime for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ResetIsrMaxStackUsage.c</td><td /><td>goto is used in ResetISRMaxStackUsage for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ResetTaskMaxExecutionTime.c</td><td /><td>goto is used in ResetTaskMaxExecutionTime for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ResetTaskMaxStackUsage.c</td><td /><td>goto is used in ResetTaskMaxStackUsage for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ResumeAllInterrupts.c</td><td /><td>goto is used in ResumeAllInterrupts for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ResumeOSInterrupts.c</td><td /><td>goto is used in ResumeOSInterrupts for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>Schedule.c</td><td /><td>goto is used in Schedule for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>SetAbsAlarm.c</td><td /><td>goto is used in SetAbsAlarm for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>SetEvent.c</td><td /><td>goto is used in SetEvent for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>SetRelAlarm.c</td><td /><td>goto is used in SetRelAlarm for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>SetScheduleTableAsync.c</td><td /><td>goto is used in SetScheduleTableAsync for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ShutdownAllCores.c</td><td /><td>goto is used in ShutdownAllCores for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>ShutdownOS.c</td><td /><td>goto is used in ShutdownOS for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>StartCore.c</td><td /><td>goto is used in StartCore for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>StartOS.c</td><td /><td>goto is used in StartOS for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>StartScheduleTableAbs.c</td><td /><td>goto is used in StartScheduleTableAbs for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>StartScheduleTableRel.c</td><td /><td>goto is used in StartScheduleTableRel for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>StartScheduleTableSynchron.c</td><td /><td>goto is used in StartScheduleTableSynchron for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>StopScheduleTable.c</td><td /><td>goto is used in StopScheduleTable for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>SuspendAllInterrupts.c</td><td /><td>goto is used in SuspendAllInterrupts for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>SuspendOSInterrupts.c</td><td /><td>goto is used in SuspendOSInterrupts for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>SyncScheduleTable.c</td><td /><td>goto is used in SyncScheduleTable for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>SyncScheduleTableRel.c</td><td /><td>goto is used in SyncScheduleTableRel for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>TerminateTask.c</td><td /><td>goto is used in TerminateTask for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>TryToGetSpinlock.c</td><td /><td>goto is used in TryToGetSpinlock for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>WaitEvent.c</td><td /><td>goto is used in WaitEvent for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>WritePeripheral.c</td><td /><td>goto is used in WritePeripheral8 for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>WritePeripheral.c</td><td /><td>goto is used in WritePeripheral16 for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr><tr><td>WritePeripheral.c</td><td /><td>goto is used in WritePeripheral32 for reasons of code efficiency across different targets. It is used in a structured manner, solely for error handling.</td></tr></table><h3 xmlns="">MISRA 2012 Rule 15.5</h3><p xmlns="">A function should have a single point of exit at the end.</p><table xmlns=""><thead><tr><th>Location</th><th>Code</th><th>Rationale</th></tr></thead><tr><td>ChainTask.c</td><td>return E_OK;</td><td>The behavior of the API requires it to exit early at OS level.</td></tr><tr><td>Os_Cfg_KL.c (2 times)</td><td>return;</td><td>Code has to exit early in error case</td></tr><tr><td>StartOS.c</td><td>return FALSE;</td><td>Code has to exit early in error case</td></tr></table><h3 xmlns="">MISRA 2012 Rule 16.1</h3><p xmlns="">All switch statements shall be well-formed.</p><table xmlns=""><thead><tr><th>Location</th><th>Code</th><th>Rationale</th></tr></thead><tr><td>ActivateTask.c</td><td>if (TaskID-&gt;dynamic-&gt;activation_count == TaskID-&gt;activation_count) { api_retval =...</td><td>Error condition requires an early and unusual exit from switch.</td></tr><tr><td>ActivateTask.c</td><td>if (TaskID-&gt;dynamic-&gt;activation_count == TaskID-&gt;activation_count) { api_retval =...</td><td>Error condition requires an early and unusual exit from switch.</td></tr><tr><td>ChainTask.c</td><td>if (TaskID-&gt;dynamic-&gt;activation_count == TaskID-&gt;activation_count) { api_retval =...</td><td>Error condition forces early exit from switch</td></tr><tr><td>ChainTask.c</td><td>if (TaskID-&gt;dynamic-&gt;activation_count == TaskID-&gt;activation_count) { api_retval =...</td><td>Error condition forces early exit from switch</td></tr></table><h3 xmlns="">MISRA 2012 Rule 18.3</h3><p xmlns="">The relational operators &gt;, &gt;=, &lt; and &lt;= shall not be applied to objects of pointer type except where they point into the same object.</p><table xmlns=""><thead><tr><th>Location</th><th>Code</th><th>Rationale</th></tr></thead><tr><td>InterruptSource.c (3 times)</td><td>const Os_ISRSourceType *source_info = &amp;Os_const_isr_sourcemap[OS_ISRTYPE_TO_INDEX...</td><td>OS_ISRTYPE_TO_INDEX uses pointer subtraction between same types to the ISR index. This is portable.</td></tr></table><h3 xmlns="">MISRA 2012 Rule 19.2</h3><p xmlns="">The union keyword should not be used.</p><table xmlns=""><thead><tr><th>Location</th><th>Code</th><th>Rationale</th></tr></thead><tr><td>Os.h</td><td>union {} Os_psetType;</td><td>The Os_psetType union is used to save memory. Different cores can have different pset sizes, but each TASK only needs to use the pset of the core it belongs to.</td></tr><tr><td>Os.h</td><td>union {} Os_tpmaskType;</td><td>The Os_tpmaskType union is used to save memory. Different cores can have different pset sizes, but each core only uses its own type.</td></tr><tr><td>Os.h</td><td>union {} saved_priority;</td><td>The saved_priority union is used to save memory. Depending on the configuration, this contains a task or interrupt priority</td></tr><tr><td>Os.h</td><td>union {} type_dependent;</td><td>The type_dependent union in Os_CounterDynType is used to save memory. Depending on the configuration, this contains data about a hardware or software counter</td></tr></table><h3 xmlns="">MISRA 2012 Rule 20.10</h3><p xmlns="">The # and ## preprocessor operators should not be used.</p><table xmlns=""><thead><tr><th>Location</th><th>Code</th><th>Rationale</th></tr></thead><tr><td>Os.h</td><td>#define ISR(x) void Os_Entry_##x(void) /* [$UKS 106] [$UKS 98] */</td><td>The ISR(x) macro uses ## to construct a name for the ISR code body. This usage does not rely on a specific order of evaluation, so its use is acceptable.</td></tr><tr><td>Os.h</td><td>#define TASK(x) void Os_Entry_##x(void) /* [$UKS 50] */</td><td>The TASK(x) macro uses ## to construct a name for the TASK code body. This usage does not rely on a specific order of evaluation, so its use is acceptable.</td></tr><tr><td>Os.h</td><td>#define ALARMCALLBACK(x) FUNC(void, OS_CODE) Os_Cbk_Alarm_##x(void) /* [$UKS 274]...</td><td>The ALARMCALLBACK(x) macro uses ## to construct a name for the callback body. This usage does not rely on a specific order of evaluation, so its use is acceptable.</td></tr><tr><td>OsTrace.h</td><td>#define Os_TriggerOnCat1ISRStart(x)    Os_SetTriggerConditions(OS_TRACE_TASKSTART...</td><td>The Os_TriggerOnCat1ISRStart(x) macro uses ## to construct a trace ID for the ISR. This usage does not rely on a specific order of evaluation, so its use is acceptable.</td></tr><tr><td>OsTrace.h</td><td>#define Os_TriggerOnCat1ISRStop(x)     Os_SetTriggerConditions(OS_TRACE_TASKEND, ...</td><td>The Os_TriggerOnCat1ISRStop(x) macro uses ## to construct a trace ID for the ISR. This usage does not rely on a specific order of evaluation, so its use is acceptable.</td></tr><tr><td>OsTrace.h</td><td>#define Os_TriggerOnAlarmExpiry(x)     Os_SetTriggerConditions(OS_TRACE_ALARM_EXP...</td><td>The Os_TriggerOnAlarmExpiry(x) macro uses ## to construct a trace ID for the ISR. This usage does not rely on a specific order of evaluation, so its use is acceptable.</td></tr><tr><td>OsTrace.h</td><td>#define Os_TriggerOnScheduleTableExpiry(x) Os_SetTriggerConditions(OS_TRACE_ALARM...</td><td>The Os_TriggerOnScheduleTableExpiry(x) macro uses ## to construct a trace ID for the ISR. This usage does not rely on a specific order of evaluation, so its use is acceptable.</td></tr><tr><td>OsTrace.h</td><td>#define Os_TriggerOnIncrementCounter(x) Os_SetTriggerConditions(OS_TRACE_TICK_COU...</td><td>The Os_TriggerOnIncrementCounter(x) macro uses ## to construct a trace ID for the ISR. This usage does not rely on a specific order of evaluation, so its use is acceptable.</td></tr><tr><td>OsTrace.h</td><td>#define Os_TriggerOnAdvanceCounter(x)   Os_SetTriggerConditions(OS_TRACE_TICK_COU...</td><td>The Os_TriggerOnAdvanceCounter(x) macro uses ## to construct a trace ID for the ISR. This usage does not rely on a specific order of evaluation, so its use is acceptable.</td></tr><tr><td>Os_Cfg.h</td><td>#define OS_TPL_FOR_TASK(n) OS_TPL_FOR_##n  /* [$UKS 2008] */</td><td>The OS_TPL_FOR_TASK(x) macro uses ## to map to the OS_TPL_FOR_ macro. This is an API requirement.</td></tr><tr><td>Os_Cfg.h</td><td>#define OS_IMASK_FOR_TASK(n) OS_IMASK_FOR_##n  /* [$UKS 2010] */</td><td>The OS_IMASK_FOR_TASK(x) macro uses ## to map to the OS_IMASK_FOR_ macro. This is an API requirement.</td></tr><tr><td>Os_Cfg.h</td><td>#define OS_CORE_FOR_ISR(i) OS_CORE_FOR_##i /* [$UKS 1922] */</td><td>The OS_CORE_FOR_ISR(x) macro uses ## to map to the OS_CORE_FOR_ macro. This is an API requirement.</td></tr><tr><td>Os_Cfg.h</td><td>#define OS_IMASK_FOR_ISR(n) OS_IMASK_FOR_##n  /* [$UKS 2011] */</td><td>The OS_IMASK_FOR_ISR(x) macro uses ## to map to the OS_IMASK_FOR_ macro. This is an API requirement.</td></tr><tr><td>Os_Cfg.h</td><td>#define Os_LogCat1ISRStart(IsrId)  /* [$UKS 1036] [$UKS 1037] [$UKS 1177] */</td><td>The Os_LogCat1ISRStart(x) macro uses ## to construct a trace ID for the ISR. This usage does not rely on a specific order of evaluation, so its use is acceptable.</td></tr><tr><td>Os_Cfg.h</td><td>#define Os_LogCat1ISREnd(IsrId)  /* [$UKS 1038] [$UKS 1039] [$UKS 1178] */</td><td>The Os_LogCat1ISREnd(x) macro uses ## to construct a trace ID for the ISR. This usage does not rely on a specific order of evaluation, so its use is acceptable.</td></tr></table><h3 xmlns="">MISRA 2012 Rule 5.4</h3><p xmlns="">Macro identifiers shall be distinct.</p><table xmlns=""><thead><tr><th>Location</th><th>Code</th><th>Rationale</th></tr></thead><tr><td>Os_ConfigInterrupts.h</td><td>/* Os_DisableAllConfiguredInterrupts_Core0 */</td><td>The first 63 characters of macro names are significant.</td></tr><tr><td>Os_ConfigInterrupts.h</td><td>/* Os_EnableAllConfiguredInterrupts_Core0 */</td><td>The first 63 characters of macro names are significant.</td></tr><tr><td>Os_ConfigInterrupts.h</td><td>/* Os_DisableAllConfiguredInterrupts_Core1 */</td><td>The first 63 characters of macro names are significant.</td></tr><tr><td>Os_ConfigInterrupts.h</td><td>/* Os_EnableAllConfiguredInterrupts_Core1 */</td><td>The first 63 characters of macro names are significant.</td></tr></table><h3 xmlns="">MISRA 2012 Rule 8.9</h3><p xmlns="">An object should be defined at block scope if its identifier only appears in a single function.</p><table xmlns=""><thead><tr><th>Location</th><th>Code</th><th>Rationale</th></tr></thead><tr><td>Os_InitializeVectorTable.c</td><td>/* Os_GICInitCluster0 */</td><td>This variable cannot be at block scope because its placement must be controllable by the memmap mechanism.</td></tr></table></div></div><p><br /></p><div id="footer"><br /><p>Copyright ETAS GmbH 2023</p></div></body></html>